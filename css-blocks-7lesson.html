<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Block-test</title>
    <link rel="stylesheet" href="css/test.css" />
  </head>
  <body>
    <div class="box-parent">
      <div class="box">1</div>
      <div class="box">2</div>
      <div class="box">3</div>
      <div class="box">4</div>
      <div class="box">5</div>
      <div class="box">6</div>
      <div class="box">7</div>
      <div class="box">8</div>
    </div>
  </body>
</html>

<!-- В фигме можно зажимать контрол чтобы увидеть расстояние, которые не подсвечиваются -->
<!-- *   -   селектор, который выбирает ВСЕ элементы на странице -->

<!--
    Блочная модель 
 У каждого элемента на странице есть определенная прямоугольная область - блок. Браузер сам добавляет размеры блоков.
 Блокова модель містить (смотри рисунок в уроке 7):
    ➔ content - область содержания (текста например)
    ➔ padding - внутреннее поле - расстояние 'content-a' до границ секции //272px//
    ➔ border - рамка (например, в графе заполнить поля телефона/имени, есть рамка) //1px width//
     border: |ширина (обычно 1px)| |стиль (ex. solid, dotted - пунктир)| |цвет| 
     border-radius: 5px;
    ➔ margin - внешний отступ (отступ к другим элентам вне элемента) //например после границы к другой ггранице отступ//
 Если не задать маржин, то браузер атоматом задаст отступ до левого края. А до правого растянется до края (до конца отцовского элемента).
     margin-left: auto   -  и по левой стороне теперь блок находится.
     |margin-left: auto|      |margin-right: auto|  -  задав два эти параметра, блок будет в центре!
     margin: 10px auto; - top bottom по 10px а справа и слева - по центру.
     Если просто по центру, то пишут: margin: 0 auto;

 Блочную модель можно посмотреть в браузере к любому элементу - f12.
 
    Геометрия
 Начиная с верхушки (top-a) по Часовой Стрелке задаются значения padding, border, margin |padding-top: 1px, border-bottom...|
ЛУЧШЕ ТАК: padding: 16px 42px 16px 42px;     / еще лучше:   padding: 16px 42px;

 Элемент (его рамеры) состоит из: content (width, heigh), paddding, border. 
Чтобы не считать, а просто задать размер Постоянный размер элемента, надо сначала прописать:    box-sizing
Эта команда задает браузеру то, как ему надо считать размеры элемента.
box-sizing: content-box; - по умолчанию - значит что именно к контенту будут добавляться элементы. 
box-sizing: corder-box; - так ЛУЧШЕ ибо мы задаем высоту и ширину по отношению к границе (как вывод мы задали размер всему элементу)
Чтобы каждый раз не прописывать это, пишем вначале стилей (в пункт base):
* { box-sizing: corder-box; }                   - ЧАСТО СПРАШИВАЮТ НА СОБЕСЕДОВАНИИ

    Типы элементов
 Для каждого элемента на страцине браузер устанавливает его тип: 
 блоковый block (элементы (теги) размещаются вертикально - один в строчке)   // header, body, footer, div //
 строчный inline (элементы размещаются горизонтально)               // span //                         
 строчно-блоковые inline-block   -   выбирает наилучшие размеры - работают как рядковые, но размеры задаются блоковые //редко исп.//
Чтобы посмотреть тип: f12 - computed - крутим вниз - display: block/inline
Сверху стиля нужного класса пишем dispay: inline;
К СТРОЧНЫМ ЭЛЕМЕНТАМ МЫ НЕ МОЖЕМ ЗАДАВАТЬ РАЗМЕРЫ! Размер строится автоматически основываясь на контент, внутренных отступов и рамки.
Плюс не работают вертикальные отступы.

 Особенности работы браузера: 
    ➔ схлопывание вертикальних отступов - Когда элементам маржин задается отдельно и браузер их схлопывает:
ЕСЛИ ЕСТЬ ДВА БЛОЧНЫХ ЭЛЕМЕНТА РЯДОМ и мы задаем им МАРЖИН РАЗНЫЕ, то расстояние между ними будет равно НАИБОЛЬШЕМУ отступу, а не их сумме! 
    ➔ выпадание вертикальних отступов      (я не пон - 7 урок 39 минута)
Ну короче надо с отцовскими элементами работать чтобы проблем этих двух не было.
    
    ВНУТРИ ОТЦОВСКОГО ЭЛЕМЕНТА, ЧТОБЫ ПОДВИНУТЬ ДОЧЕРНЕЕ ЭЛЕМЕНТЫ, ИСПОЛЬЗУЕМ ПАДИНГ!!!!!

    Структурные псевдоклассы
 Структурные псевдоклассы - это способ выбора дочернего элемента (не все, а конкретный элемент с таких же дочерных).
Таким образом, не надо прописывать дополнительные классы.
 Основные типы:
    ➔ first-child      -       первый
    ➔ last-child       -       последний                                   .box:last-child {background-color: gold;}
    ➔ not()            -       все элементы, кроме определенных            .box:not(:last-child, :first-child) {background-color: gold;}
    ➔ nth-child()      -       определенный элемент                        .box:nth-child(3), .box:nth-child(4) {background-color: darkcyan;}
.box:nth-child(odd) - каждый непарный элемент       /      .box:nth-child(even) - каждый парный элемент
.box:nth-child(n+3) - Считать начнет с нуля: 0+3=3элемент, 4, 5 и тд. Затронутся все элементы начиная с третьего. МАТЕМАТИКА ХАЛОУ!
.box:nth-child(4n+4) {background-color: gold;} - каждый четвертый элемент

display: none;          -       просто спрячет элементы И ДЛЯ БРАУЗЕРА ОН СПРЯЧЕТ , а иногда надо чтобы браузер видел и показывал (например при 
использовании скрин ридера (для людей с плохим зрением)). 
class = "visually-hidden"
.visually-hidden{position:absolute; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden;}

// У нас в проекте расстояние секции до секции одинаковое - 96px //

Чтобы расширение (1440х798) не растягивалось, надо это задать
Cлева и справа значения фиксировать нельзя, ибо при добавлении текста будет гг      -       просто пишем  text-align: center;

МАРЖИН К ЗАГЛАВЛЕНИЯМ И К ПАРАГРАФАМ <p> ДОБАВЛЯЕТ САМ БРАУЗЕР !!! ПОЭТОМУ В БЕЙС БАЗА ЗАДАЕМ h1, h2, h3, h4, h5, h6, p {margin-top: 0}
    Задаем только для верхушки ибо иногда надо именно такой отсуп снизу, какой и задает браузер. // Плюс это негласное правило //
    А маржин топ мы никогда (как правило) не задаем.

    К СЕКЦИЯМ ТОЖЕ ПИШЕМ В БАЗЕ: .section {padding: 48px 0;}
    
    МАРЖИНЫ ЗАДАЕМ ПЕРЕД РАЗМЕРАМИ



-->
