<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Block-test</title>
    <link rel="stylesheet" href="css/test.css" />
  </head>
  <body>
    <div class="flex-container">
      <div class="item">1</div>
      <div class="item">2</div>
      <div class="item">3</div>
      <div class="item">4</div>
      <div class="item">5</div>
      <div class="item">6</div>
      <div class="item">7</div>
      <div class="item">8</div>
      <div class="item">1</div>
      <div class="item">2</div>
      <div class="item">3</div>
      <div class="item">4</div>
      <div class="item">5</div>
      <div class="item">6</div>
      <div class="item">7</div>
      <div class="item">8</div>
      <div class="item">1</div>
      <div class="item">2</div>
      <div class="item">3</div>
      <div class="item">4</div>
      <div class="item">5</div>
      <div class="item">6</div>
      <div class="item">7</div>
      <div class="item">8</div>
      <div class="item">1</div>
      <div class="item">2</div>
      <div class="item">3</div>
      <div class="item">4</div>
      <div class="item">5</div>
      <div class="item">6</div>
      <div class="item">7</div>
      <div class="item">8</div>
    </div>
  </body>
</html>

<!-- В фигме можно зажимать контрол чтобы увидеть расстояние, которые не подсвечиваются -->
<!-- *   -   селектор, который выбирает ВСЕ элементы на странице -->
<!-- <br> - break line - переход текста на новую строку -->
<!-- calc((100%-40px) / 3) - УКАЗАТЬ БРАУЗЕРУ ЧТОБЫ ОН ПОСЧИТАЛ - calculate -->

<!--
    Блочная модель 
 У каждого элемента на странице есть определенная прямоугольная область - блок. Браузер сам добавляет размеры блоков.
 Блокова модель містить (смотри рисунок в уроке 7):
    ➔ content - область содержания (текста например)
    ➔ padding - внутреннее поле - расстояние 'content-a' до границ секции //272px//
    ➔ border - рамка (например, в графе заполнить поля телефона/имени, есть рамка) //1px width//
     border: |ширина (обычно 1px)| |стиль (ex. solid, dotted - пунктир)| |цвет| 
     border-radius: 5px;
    ➔ margin - внешний отступ (отступ к другим элентам вне элемента) //например после границы к другой ггранице отступ//
 Если не задать маржин, то браузер атоматом задаст отступ до левого края. А до правого растянется до края (до конца отцовского элемента).
     margin-left: auto   -  и по левой стороне теперь блок находится.
     |margin-left: auto|      |margin-right: auto|  -  задав два эти параметра, блок будет в центре!
     margin: 10px auto; - top bottom по 10px а справа и слева - по центру.
     Если просто по центру, то пишут: margin: 0 auto;

 Блочную модель можно посмотреть в браузере к любому элементу - f12.
 
    Геометрия
 Начиная с верхушки (top-a) по Часовой Стрелке задаются значения padding, border, margin |padding-top: 1px, border-bottom...|
ЛУЧШЕ ТАК: padding: 16px 42px 16px 42px;     / еще лучше:   padding: 16px 42px;

 Элемент (его рамеры) состоит из: content (width, heigh), paddding, border. 
Чтобы не считать, а просто задать размер Постоянный размер элемента, надо сначала прописать:    box-sizing
Эта команда задает браузеру то, как ему надо считать размеры элемента.
box-sizing: content-box; - по умолчанию - значит что именно к контенту будут добавляться элементы. 
box-sizing: border-box; - так ЛУЧШЕ ибо мы задаем высоту и ширину по отношению к границе (как вывод мы задали размер всему элементу)
Чтобы каждый раз не прописывать это, пишем вначале стилей (в пункт base):
* { box-sizing: border-box; }                   - ЧАСТО СПРАШИВАЮТ НА СОБЕСЕДОВАНИИ

    Типы элементов
 Для каждого элемента на странице браузер устанавливает его тип: 
 блоковый block (элементы (теги) размещаются вертикально - один в строчке)   // header, body, footer, div //
 строчный inline (элементы размещаются горизонтально)               // span //                         
 строчно-блоковые inline-block   -   выбирает наилучшие размеры - работают как рядковые, но размеры задаются блоковые //редко исп.//
Чтобы посмотреть тип: f12 - computed - крутим вниз - display: block/inline
Сверху стиля нужного класса пишем dispay: inline;
К СТРОЧНЫМ ЭЛЕМЕНТАМ МЫ НЕ МОЖЕМ ЗАДАВАТЬ РАЗМЕРЫ! Размер строится автоматически основываясь на контент, внутренных отступов и рамки.
Плюс не работают вертикальные отступы.

 Особенности работы браузера: 
    ➔ схлопывание вертикальних отступов - Когда элементам маржин задается отдельно и браузер их схлопывает:
ЕСЛИ ЕСТЬ ДВА БЛОЧНЫХ ЭЛЕМЕНТА РЯДОМ и мы задаем им МАРЖИН РАЗНЫЕ, то расстояние между ними будет равно НАИБОЛЬШЕМУ отступу, а не их сумме! 
    ➔ выпадание вертикальних отступов      (я не пон - 7 урок 39 минута)
Ну короче надо с отцовскими элементами работать чтобы проблем этих двух не было.
    
    ВНУТРИ ОТЦОВСКОГО ЭЛЕМЕНТА, ЧТОБЫ ПОДВИНУТЬ ДОЧЕРНЕЕ ЭЛЕМЕНТЫ, ИСПОЛЬЗУЕМ ПАДИНГ!!!!!

    ДЛЯ ВЫРАВНИВАНИЯ СЕКЦИЙ ИСПОЛЬЗУЕМ ПАДДИНГ (смотри стиль .container)

    Структурные псевдоклассы
 Структурные псевдоклассы - это способ выбора дочернего элемента (не все, а конкретный элемент с таких же дочерных).
Таким образом, не надо прописывать дополнительные классы.
 Основные типы:
    ➔ first-child      -       первый
    ➔ last-child       -       последний                                   .box:last-child {background-color: gold;}
    ➔ not()            -       все элементы, кроме определенных            .box:not(:last-child, :first-child) {background-color: gold;}
    ➔ nth-child()      -       определенный элемент                        .box:nth-child(3), .box:nth-child(4) {background-color: darkcyan;}
.box:nth-child(odd) - каждый непарный элемент       /      .box:nth-child(even) - каждый парный элемент
.box:nth-child(n+3) - Считать начнет с нуля: 0+3=3элемент, 4, 5 и тд. Затронутся все элементы начиная с третьего. МАТЕМАТИКА ХАЛОУ!
.box:nth-child(4n+4) {background-color: gold;} - каждый четвертый элемент

display: none;          -       просто спрячет элементы И ДЛЯ БРАУЗЕРА ОН СПРЯЧЕТ , а иногда надо чтобы браузер видел и показывал (например при 
использовании скрин ридера (для людей с плохим зрением)). 
class = "visually-hidden"
.visually-hidden{position:absolute; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden;}

// У нас в проекте расстояние секции до секции одинаковое - 96px //

Чтобы расширение (1440х798) не растягивалось, надо задать КОНТЕЙНЕР: 
<div class ="container">All section</div>           .container {width: 1240px;} --- В БАЗЕ БЕЙС

Figma -> view -> layout grids     -     нам надо узнать размер от левой красной полоски до правой. //1240 в проекте//
НО СТАВИТЬ СТАЛОЕ ЗНАЧЕНИЕ НЕЛЬЗЯ, ЧТОБЫ НА МОБИЛКАХ МОЖНО БЫЛО ПРОЧИТАТЬ ЧТО-ТО! Наше значение будет Максимумом!!!
.container {width: 100%; max-width: 1240px;} - /Челу пофиг, просто ищем контейнер, чтобы узнать размер/
//КАРТЕ (ТО, ЧТО ВСТАВЛЯЕМ в сайт) ТОЖЕ ЗАДАТЬ НАДО МАКС ШИРИНУ (иногда надо и высоту задавать так же) НО У МЕНЯ НЕ ВЫШЛО!//

ШОБ ТЕКСТ НЕ ПРИЛИПАЛ К КРАЯМ - ЗАДАЕМ ПАДИНГ В КОНТЕЙНЕ ПО 16рх (или по 24рх).

ОТСТУПЫ И РАЗМЕРЫ ПАРНЫЕ ВОСЬМИ 8 8 8 8 8!!!!   -   Восьмипиксельная сетка    -   исследования показали что так легче читать.

Эти отступы по 24рх надо добавить в макс ширину:
.container{
  width: 100%;
  max-width: 1288px;
  margin: 0 auto;
  padding: 0 24px;
}

Cлева и справа значения фиксировать нельзя, ибо при добавлении текста будет гг      -       просто пишем  text-align: center;

МАРЖИН К ЗАГЛАВЛЕНИЯМ И К ПАРАГРАФАМ <p> ДОБАВЛЯЕТ САМ БРАУЗЕР !!! ПОЭТОМУ В БЕЙС БАЗА ЗАДАЕМ h1, h2, h3, h4, h5, h6, p {margin-top: 0}
    Задаем только для верхушки ибо иногда надо именно такой отсуп снизу, какой и задает браузер. // Плюс это негласное правило //
    А маржин топ мы никогда (как правило) не задаем.

    К СЕКЦИЯМ ТОЖЕ ПИШЕМ В БАЗЕ: .section {padding: 48px 0;}
    
    МАРЖИНЫ ЗАДАЕМ ПЕРЕД РАЗМЕРАМИ    //не пон//

    ДЛЯ БОДИ МАРЖИН ТОЖЕ УДАЛИТЬ 



    FLEXBOX
 Чтобы разместить элементы определенным образом на странице надо этот флекс. Короче это Гибкое (flex) управление элементами.
//Дабы на мобилках сайт отображался так, как был сконструирован, а не просто уменьшался//
Flexbox - Css-модуль, который определяет размещения, выравнивания и разпределения пространства между элементами в контейнере.

  Flex-контейнер
 Особенности контейнера:
    ➔ display            -       display: flex; - элементы выравниваются по горизонтали (не путать с инлайном) - ЭТО ГЛАВНАЯ ОСЬ
    ➔ flex-direction     -       меняет оси - меняет направление (с горизонтали на вертикаль например). row-reverse - с право налево. column-reverse.
    ➔ justify-content    -       выравнивает элементы на оси. justify-content: center / flex-start (по умолчанию) / flex-end / 
space-around - расстояние между элементами расчитывается равномерно по оси, добавляя половину расстояния по краям страницы /
space-evenly - тоже самое, но края не половина рассстояния, а полное.
space-between - тоже самое, но без краев! - ЭТО ЧАЩЕ ВСЕГО - например текст и картинку по сторонам надо расставить, то есть когда 2 элемента.
    ➔ align-items        -       ТО ЖЕ ЧТО И justify, только выравнивает элементы вдоль поперечной оси. Чтобы увидеть, надо элементы разных размеров.
По умолчанию align-items: stretch   -   элементы растягиваются(/впихуются?) от начала до конца отцовского элемента.
В случае старт эл-т просто ставится на начало оси. Мы будем юзать ТОЛЬКО ЦЕНТЕР (в основном).
    ➔ flex-wrap          -       Если элементов много, они будут уменьшаться чтобы вместится на оси. flex-wrap: wrap - эл-ты перейдут на новую строку.
По умолчанию flex-wrap:nowrap;    wrap-reverse: Елементи переносятся до наступного рядка у зворотньому порядку. 
    ➔ align-content      -       Редко. Выравнивание вдоль поперечной оси в случае если это позволяет флекс контейнер (в контейнере)
    ➔ flex-flow          -       flex-flow: row wrap;  - для встановлення рядків та перенесення їх (объединяет flex-direction and flex-wrap).

    Flex-элемент - это дети flex-контейнера. ЭТИМ ЭЛЕМЕНТАМ НАДО ЗАДАТЬ ОТДЕЛЬНЫЙ КЛАСС! и там уже писать нижние команды!
  Особенности елемента:
      ➔ flex-basis       -       Можно не задавать ширину элемента, а задать через flex-basis: 100px; Так лучше ибо браузер расчитывает flex-basis еще до
того, как отрисовывать элементы внутри контейнера.  flex-basis: auto; - размер будет зависеть от содержания.
      ➔ flex-grow        -       flex-grow: 0;  -  по умоланию. flex-grow: 1;  -  займет все доступное место в контейнере (растянется). 
flex-grow: 2;   -   если есть два и более элемента с флексгроу, то этот будет занимать в два раза больше места чем эл-нт с флексгроу 1.
      ➔ flex-shrink      -       По умолч.: 1;  Полная противоположность флексгроу. flex-shrink: 0; - запрещаем элементу сужаться (сужаться будут остальные).
flex-shrink: 3; - элемент будет в три раза больше сужаться (чем элемент с 1).
      ➔ align-self       -       Выравнивание по поперечной оси КОНКРЕТНОГО ЭЛЕМЕНТА. Пишем не просто Старт, а ФЛЕКС-старт.
      ➔ order            -       Управление порядком. order: 4; - станет на место четвертого элемента, а остальных подвинет на один блок назад. Но надо прописать
обязательно dispay: flex;  Важно понимать что по умолчанию у элементов это значение 0. Поэтому если написать одному значение 1, то он уйдет в самый конец.
Поэтому можно прописывать order: -1;

  flex: 0 1 auto; - flex-grow/shrink/basis - Можно задать все сразу. Но лучше отдельно.

 У flex-контейнері скасовується більшість правил:
  ➔ //елементи втрачають «тип», перестають бути рядковими або блоковими// - Они все становятся блочными, но в стилях браузер вычеркивает блок или инлайн.
  ➔ блокові елементи перестають розташовуватись один під одним            - То есть в ряд элементы горизонтально становятся.
  ➔ крайні відступи на стику з межею батька не випадають а вертикальні відступи елементів не схлопуються     -     короче раньше если мы писали двум
соседним элементам маржин (1му - 20, а 2му - 30), то был бы больший просто (30рх - схолопание). А у флекс бокса они будут суммироваться..

  Чтобы свойства не конфликтовали между собой, лучше ставить еще один блок внутри блока (c display: flex), а не прописывать два стиля. 

  КО ВСЕМ СПИСКАМ ДОБАВЛЯЮТСЯ ПАДДИНГ (40рх) И МАРЖИН (18рх) АВТОМАТИЧЕСКИ - не забудь убрать. Просто в ul{margin: 0; padding: 0; list-style-type: 0}

  .header-menu{display: flex; gap = 64px;}        -     gap - пространство, отрезок между элементами. 
  .advantages-list {display: flex; justify-content: space-between; gap: 40px; color: var(--color-primary-light); font-size: 20px;}
  Здесь геп для того, чтобы при сужении элементы не склеивались.

  Если картинка - то лучше не gap, а space-between. Но gap все равно маленький ставим (40рх)
-->